# Architecture Documentation - JWT Token Flow

## How JWT Secrets Are Configured

### Configuration Flow

```
1. Environment (.env file)
   ├── JWT_ACCESS_SECRET=xxx
   └── JWT_REFRESH_SECRET=yyy

2. Config Class (src/config.py)
   ├── JWT_ACCESS_SECRET_KEY = os.getenv('JWT_ACCESS_SECRET')
   ├── JWT_REFRESH_SECRET_KEY = os.getenv('JWT_REFRESH_SECRET')
   └── JWT_SECRET_KEY = JWT_ACCESS_SECRET_KEY  ← Flask-JWT-Extended reads this!

3. Flask App (src/app.py)
   ├── app.config.from_object(config[config_name])  ← Loads all config
   └── jwt.init_app(app)  ← Reads app.config['JWT_SECRET_KEY']

4. Token Operations
   ├── Access Token: Flask-JWT-Extended uses app.config['JWT_SECRET_KEY']
   └── Refresh Token: Manually uses app.config['JWT_REFRESH_SECRET_KEY']
```

### Why Two Different Approaches?

**Access Tokens (Automatic):**
- Generated by: `create_access_token(identity, additional_claims)`
- Signed with: `app.config['JWT_SECRET_KEY']` (automatically by Flask-JWT-Extended)
- Verified by: `verify_jwt_in_request()` (automatically by Flask-JWT-Extended)
- Secret used: `JWT_ACCESS_SECRET_KEY` (via `JWT_SECRET_KEY`)

**Refresh Tokens (Manual):**
- Generated by: `TokenService.generate_refresh_token()` using PyJWT directly
- Signed with: `app.config['JWT_REFRESH_SECRET_KEY']` (manually specified)
- Verified by: `TokenService.verify_refresh_token()` using PyJWT directly
- Secret used: `JWT_REFRESH_SECRET_KEY`

**Why?** Flask-JWT-Extended doesn't natively support separate secrets for access and refresh tokens, so we:
- Use Flask-JWT-Extended for access tokens (it's designed for this)
- Use PyJWT directly for refresh tokens (to use a different secret)

## Configuration Variables Explained

### In `src/config.py`:

```python
# Environment variable mapping
JWT_ACCESS_SECRET_KEY = os.getenv('JWT_ACCESS_SECRET', 'default')
JWT_REFRESH_SECRET_KEY = os.getenv('JWT_REFRESH_SECRET', 'default')

# Flask-JWT-Extended compatibility
# This is THE KEY: Flask-JWT-Extended looks for JWT_SECRET_KEY in app.config
JWT_SECRET_KEY = JWT_ACCESS_SECRET_KEY
```

### What Flask-JWT-Extended Reads:

When you call `jwt.init_app(app)`, Flask-JWT-Extended reads these from `app.config`:

| Config Key | Used For | Set In Our Code |
|------------|----------|-----------------|
| `JWT_SECRET_KEY` | Access token signing & verification | ✅ Set to `JWT_ACCESS_SECRET_KEY` |
| `JWT_ACCESS_TOKEN_EXPIRES` | Access token TTL | ✅ 15 minutes |
| `JWT_REFRESH_TOKEN_EXPIRES` | Refresh token TTL (we don't use this) | ✅ 7 days (for reference only) |
| `JWT_TOKEN_LOCATION` | Where to look for tokens | ✅ `['headers']` |
| `JWT_HEADER_NAME` | Header name | ✅ `'Authorization'` |
| `JWT_HEADER_TYPE` | Header prefix | ✅ `'Bearer'` |

### What We Use Manually:

| Config Key | Used For | Where |
|------------|----------|-------|
| `JWT_REFRESH_SECRET_KEY` | Refresh token signing & verification | `src/services/token_service.py` |

## Token Generation Flow

### Access Token Generation

```python
# In src/api/auth.py (login endpoint)
access_token = TokenService.generate_access_token(
    str(user.id),
    {'email': user.email, 'role': user.role.value}
)

# In src/services/token_service.py
@staticmethod
def generate_access_token(identity: str, additional_claims: dict = None) -> str:
    # Flask-JWT-Extended's create_access_token internally:
    # 1. Reads current_app.config['JWT_SECRET_KEY']
    # 2. Reads current_app.config['JWT_ACCESS_TOKEN_EXPIRES']
    # 3. Creates JWT with those settings
    return create_access_token(
        identity=identity,
        additional_claims=additional_claims or {}
    )
```

**Internally, Flask-JWT-Extended does:**
```python
# Pseudo-code of what Flask-JWT-Extended does
def create_access_token(identity, additional_claims):
    secret = current_app.config['JWT_SECRET_KEY']  # ← Reads from app.config
    expires = current_app.config['JWT_ACCESS_TOKEN_EXPIRES']
    payload = {
        'sub': identity,
        'exp': datetime.utcnow() + expires,
        'type': 'access',
        **additional_claims
    }
    return jwt.encode(payload, secret, algorithm='HS256')
```

### Refresh Token Generation

```python
# In src/api/auth.py (login endpoint)
refresh_token = TokenService.generate_refresh_token(
    str(user.id),
    {'sessionId': str(session.id)}
)

# In src/services/token_service.py
@staticmethod
def generate_refresh_token(identity: str, additional_claims: dict = None) -> str:
    # We manually use PyJWT because Flask-JWT-Extended doesn't support
    # separate secrets for refresh tokens
    expires_delta = current_app.config['JWT_REFRESH_TOKEN_EXPIRES']
    expires = datetime.utcnow() + expires_delta

    payload = {
        'sub': identity,
        'exp': expires,
        'type': 'refresh',
        'iat': datetime.utcnow(),
        **(additional_claims or {})
    }

    # IMPORTANT: Use JWT_REFRESH_SECRET_KEY, not JWT_SECRET_KEY
    refresh_secret = current_app.config['JWT_REFRESH_SECRET_KEY']
    return pyjwt.encode(payload, refresh_secret, algorithm='HS256')
```

## Token Verification Flow

### Access Token Verification

```python
# In src/api/decorators.py
@jwt_required_with_user
def some_endpoint(user):
    # The decorator calls verify_jwt_in_request()
    pass

def jwt_required_with_user(fn):
    def wrapper(*args, **kwargs):
        verify_jwt_in_request()  # ← Flask-JWT-Extended automatically uses JWT_SECRET_KEY
        user_id = get_jwt_identity()
        # ...
    return wrapper
```

**Internally, Flask-JWT-Extended does:**
```python
# Pseudo-code of what Flask-JWT-Extended does
def verify_jwt_in_request():
    token = get_token_from_header()  # Reads Authorization: Bearer <token>
    secret = current_app.config['JWT_SECRET_KEY']  # ← Reads from app.config
    payload = jwt.decode(token, secret, algorithms=['HS256'])
    # Stores payload in request context for get_jwt_identity() to use
    return payload
```

### Refresh Token Verification

```python
# In src/api/auth.py (refresh endpoint)
try:
    payload = TokenService.verify_refresh_token(refresh_token)
except ValueError as e:
    return jsonify({'message': str(e)}), 401

# In src/services/token_service.py
@staticmethod
def verify_refresh_token(token: str) -> dict:
    # IMPORTANT: Use JWT_REFRESH_SECRET_KEY, not JWT_SECRET_KEY
    refresh_secret = current_app.config['JWT_REFRESH_SECRET_KEY']
    payload = pyjwt.decode(token, refresh_secret, algorithms=['HS256'])
    return payload
```

## Summary

**The key insight:** Flask-JWT-Extended reads `app.config['JWT_SECRET_KEY']` **automatically** when you call `jwt.init_app(app)`. We don't need to pass it explicitly to `create_access_token()` or `verify_jwt_in_request()` because they access it via the Flask application context (`current_app.config`).

**Configuration chain:**
```
.env file
  ↓ os.getenv()
config.py (JWT_ACCESS_SECRET_KEY, JWT_SECRET_KEY)
  ↓ app.config.from_object()
app.config dict
  ↓ jwt.init_app(app)
Flask-JWT-Extended (reads JWT_SECRET_KEY)
  ↓ create_access_token(), verify_jwt_in_request()
Token operations
```

**Access tokens:** Fully managed by Flask-JWT-Extended using `JWT_SECRET_KEY`
**Refresh tokens:** Manually managed using `JWT_REFRESH_SECRET_KEY` for separate security
